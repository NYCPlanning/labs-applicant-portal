import { 
  Injectable, 
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import * as jwt from 'jsonwebtoken';
import * as moment from 'moment';
import { ConfigService } from '../config/config.service';
import { ContactService } from '../contact/contact.service';

/**
 * This service is responsible for verifying NYCID tokens presented
 * by the user and generating new ZAP token for the user.
 *
 * @class      AuthService (name)
 */
@Injectable()
export class AuthService {
  // required env variables
  NYCID_TOKEN_SECRET = '';
  ZAP_TOKEN_SECRET = '';

  constructor(
    private readonly config: ConfigService,
    private readonly contactService: ContactService,
  ) {
    this.NYCID_TOKEN_SECRET = this.config.get('NYCID_TOKEN_SECRET');
    this.ZAP_TOKEN_SECRET = this.config.get('ZAP_TOKEN_SECRET');
  }

  /**
   * Generates a new app token, using NYC.ID's expiration, and including the CRM contact id
   *
   * @param      {string}  contactId  The CRM contactid
   * @param      {string}  exp        A string coercable to a Date
   * @param      {object}  exp        Metadata about the nyc ID user
   * @return     {string}             String representing ZAP token
   */
  private signNewToken(
    contactId: string,
    nycIdAccount: any = {},
  ): string {
    const { ZAP_TOKEN_SECRET } = this;
    const {
      nycExtTOUVersion,
      mail,
      scope,
      nycExtEmailValidationFlag,
      GUID,
      userType,
      exp,
      jti,
    } = nycIdAccount;

    return jwt.sign({
      // JWT standard name for expiration - see https://github.com/auth0/node-jsonwebtoken#token-expiration-exp-claim
      exp,

      // CRM id â€” added to this app's JWT for later queries
      contactId,

      // additional NYC.ID account information
      nycExtTOUVersion,
      mail,
      scope,
      nycExtEmailValidationFlag,
      GUID,
      userType,
      jti,
    }, ZAP_TOKEN_SECRET);
  }

  private verifyToken(token, secret): string | {} {
    try {
      return jwt.verify(token, secret);
    } catch (e) {
      const error = {
        code: "INVALID_TOKEN",
        title: "Invalid token",
        detail: `Could not verify token. ${e}`,
      };
      console.log(error);
      throw new HttpException(error, HttpStatus.UNAUTHORIZED);
    }
  }

  /**
   * Verifies a JWT with the NYCID signature. Returns the token object.
   *
   * @param      {string}  token   The token
   * @return     {object}     { mail: 'string', exp: 'string' }
   */
  private verifyNYCIDToken(token): any {
    const { NYCID_TOKEN_SECRET } = this;

    try {
      return this.verifyToken(token, NYCID_TOKEN_SECRET);
    } catch (e) {
      const error = {
        code: "INVALID_NYCID_TOKEN",
        title: "Invalid NYCID token",
        detail: "The acquired NYCID token is invalid."
      };
      console.log(error);
      throw new HttpException(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }


  /**
   * This function extracts the email from an NYCIDToken and uses it to
   * look up a Contact in CRM. It returns to the client a ZAP token holding
   * (signed with) the acquired Contact's contactid. 
   * 
   * @param      {string}  NYCIDToken  Token from NYCID
   * @return     {string}              String representing generated ZAP Token
   */
  public async generateNewToken(NYCIDToken: string): Promise<string> {
    const nycIdAccount = this.verifyNYCIDToken(NYCIDToken);

    // need the email to lookup a CRM contact.
    const { mail, nycExtEmailValidationFlag, GUID } = nycIdAccount;

    const contact = await this.contactService.findOneByEmail(mail);

    if (!contact) {
      const error = {
        code: "CONTACT_NOT_FOUND",
        title: "Contact not found",
        detail: `CRM Contact not found for given email or ID: ${mail}`,
      }
      console.log(error);
      throw new HttpException(error, HttpStatus.UNAUTHORIZED);
    }

    // if their e-mail is validated, associate the NYCID guid
    if (nycExtEmailValidationFlag && !contact.dcp_nycid_guid) {
      await this.contactService.update(contact.contactid, {
        dcp_nycid_guid: GUID,
      });
    }

    return this.signNewToken(contact.contactid, nycIdAccount);
  }

  /**
   * Validates the current signed JWT generated by ZAP API.
   *
   * @param      {string}  token   The token
   */
  public validateCurrentToken(token: string) {
    try {
      return this.verifyZapToken(token);
    } catch (e) {
      const error = {
        code: "INVALID_ZAP_TOKEN",
        title: "Invalid login token provided",
        detail: "The provided ZAP token is invalid."
      };
      console.log(error);
      throw new HttpException(error, HttpStatus.UNAUTHORIZED);
    }
  }

  /**
   * Verifies a JWT with the ZAP signing secret. Returns a token object.
   *
   * @param      {string}  token   The token
   * @return     {any}     { mail: 'string', exp: 'string' }
   */
  private verifyZapToken(token): any {
    const { ZAP_TOKEN_SECRET } = this;

    try {
      return this.verifyToken(token, ZAP_TOKEN_SECRET);
    } catch (e) {
      const error = {
        code: "VERIFY_ZAP_TOKEN_ERROR",
        title: "Error verifying ZAP token",
        detail: "Perhaps the provided ZAP token is invalid."
      };
      console.log(error);
      throw new HttpException(error, HttpStatus.UNAUTHORIZED);
    }
  }
}
